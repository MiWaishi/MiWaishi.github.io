<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-09-13T22:48:37+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">sun Blog Title</title><subtitle>A brief description of your blog.</subtitle><author><name>Your Name</name><email>your-email@example.com</email></author><entry><title type="html">树状数组(Binary Indexed Tree)</title><link href="http://localhost:4000/2025/09/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary-Indexed-Tree.html" rel="alternate" type="text/html" title="树状数组(Binary Indexed Tree)" /><published>2025-09-12T00:00:00+08:00</published><updated>2025-09-12T00:00:00+08:00</updated><id>http://localhost:4000/2025/09/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary%20Indexed%20Tree</id><content type="html" xml:base="http://localhost:4000/2025/09/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary-Indexed-Tree.html"><![CDATA[<h1 id="树状数组binary-indexed-tree">树状数组(Binary Indexed Tree)</h1>
<p class="meta">12 Sep 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>普通的树状数组可以处理单点修改和区间查询。</li>
  <li>树状数组维护的信息必须满足<strong>结合律</strong>和<strong>可差分</strong>（如加法，乘法，异或）。</li>
  <li>利用差分，可以实现区间修改。</li>
</ul>

<p><strong>2.原理</strong></p>

<p>将一段长度为n的区间拆成不多于<strong>logn段区间</strong>。</p>

<p><img src="/Users/stanchen/Desktop/fenwick.svg" alt="fenwick" style="zoom:80%;" /></p>

<p>这样处理各种问题效率要更高。如计算a[1…7]的和，过程：从c[7]开始往前跳，发现c[7]只管辖a[7]这个元素；然后找到c[6]，发现c[6]管辖a[5…6]；然后找到c[4]，发现c[4]管辖a[1…4]，然后再试图跳到c[0]，但实际上不存在，所以不跳了。因此答案为c[7]+c[6]+c[4]。</p>

<p>如果查询的是a[4…7]，那么答案是：查询a[1…7] - 查询a[1…3]。</p>

<p><strong>2.1 管辖区间</strong></p>

<p>问题是，c[x]管辖的区间长度到底是多少（向左边延伸多长）？</p>

<p>规定c[x]管辖的区间长度为 2的k次方，其中：</p>

<ul>
  <li>k表示x的二进制中，最低位的1所在的数位。</li>
  <li>2的k次方(十进制) 表示，在x的二进制中，最低位的1以及后面所有的0组成的数。</li>
</ul>

<p>比如，c[88]管辖的区间长度：</p>

<p>88(10) = 01011000(2)，其中最低位的1和后面的0组成的数字为1000(2)，即8(10)，所以长度为8，c[88]管辖a[81…88]。</p>

<p>可以用 <strong>lowbit(x)</strong> 求x二进制数中最低位1和后面的0组成的数。因为lowbit(x)所求得的数在十进制中是 2的k次方，也就是区间的长度，那么c[x]管辖的区间就是a[x-lowbit(x)+1]。</p>

<p><strong>2.2 lowbit原理</strong></p>

<p><strong>原码</strong>：最简单的机器数表示法，最高位为符号位，1表示负数，0表示正数，其余位存放该数 2进制的绝对值。</p>

<p><strong>反码</strong>：正数的反码是其原码；数的反码是其原码除符号位外，按位取反。</p>

<p>1110(-1) + 1101(-2) = 1011(-4)，而正确答案应该是-3;</p>

<p>1110(-1) + 1100(-3) = 1010(-5)，而正确答案应该是-4。</p>

<p>计算结果和正确答案差了1，所以引申出补码的概念来解决问题。</p>

<p><strong>补码</strong>：正数的补码是其原码，负数的补码是其原码+1。</p>

<p>lowbit(x) = x &amp; -x，-x在运算过程中，其形式是补码（存储过程中也是）。</p>

<p>通过这样的运算，可以得到最低位的1后后面的0组成的数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  	<span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3.实现</strong></p>

<p><strong>3.1区间查询</strong></p>

<p>对于一个区间[L, R]的询问，都可以拆解成[1, L-1]的询问，以及[1, R]的询问，再用后者减去前者。</p>

<p>具体的查询过程：查询a[1…x]的和</p>

<ol>
  <li>从c[x]往前跳，找到c[x]管辖a[x-lowbit(x)+1…..x];</li>
  <li>x -= lowbit(x)，如果 x = 0说明已经跳到尽头;</li>
  <li>将跳到的c求和。</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  	<span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
    		<span class="n">x</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  	<span class="p">}</span>
  	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3.2单点修改</strong></p>

<p>对于长度为n的数列，若修改第x个元素，那么不仅会影响这个元素本身，还会影响包含这个数字的所有c。</p>

<p>那么从第x个元素开始，找到所有包含此元素的c，都进行修改。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 将第x个元素加上k</span>
  	<span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  	  	<span class="n">c</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>4. 复杂度</strong></p>

<p>空间复杂度为O(n)。</p>

<p>时间复杂度:</p>
<ul>
  <li>对于查询操作，最坏情况是将这个数组c遍历一遍，所需时间O(log n)。因为将长度为n的数列为成了log n个区间。</li>
  <li>对于修改操作，点x的高度为log2 (lowbit(x))，不会超过log 2 n, 同样是log级别：O(log n)。</li>
</ul>

<p><strong>5.例题</strong></p>

<p><strong>Example 1</strong><a href="https://www.luogu.com.cn/problem/P3374">洛谷 P3374 模版1</a></p>

<p>单点修改，区间求和，模版代码如下</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define int long long
</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="mi">500010</span><span class="p">];</span>
<span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	  	<span class="n">t</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
		<span class="n">x</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	  	<span class="n">sum</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="n">x</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	  	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
		<span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
	  	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">op</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		  	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
			<span class="n">update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">query</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	 	<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Example 2</strong> <a href="https://www.luogu.com.cn/problem/P3368">洛谷 P3368 模版2</a></p>

<p>区间修改，单点查询。要用到差分的思想。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[] 1  5  4  2  3
d[] 1  4 -1 -2 -1
</code></pre></div></div>

<p>在[2, 4]的区间上都加上2：若运用普通的差分，则d[2] += 2, d[5] -= -2。</p>

<p>那么如何与树状数组结合？将原数组转化为差分数组后，在差分数组上操作，此题就与模版1无异了。在差分数组上单点修改，再求1….x的区间和，就可以找到第x个元素的值。</p>

<p>三个函数与模版1一样，主函数中的不同之处，就是把原数组转化为差分数组。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">input</span><span class="p">();</span>
  	
        <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 差分</span>
                <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
  	
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// 差分数组上建树</span>
                <span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  	
        <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">op</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">&gt;&gt;</span> <span class="n">k</span><span class="p">;</span>
                        <span class="n">update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
                        <span class="n">update</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">);</span> <span class="c1">// 利用差分来修改</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
                        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">query</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/P1908">洛谷 P1908 逆序对</a></p>

<p>描述：一个长为n的数列，找到每个数左侧比它大的数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input								output
6									11
5 4 2 6 3 1
</code></pre></div></div>

<p>思路：维护一个桶数组，记录每个数字出现的次数。将数列中的数依次读入，求得当前数的答案之后，再放入到桶数组中。</p>

<p>例如，一个桶数组如下（原数组即为样例）：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i   1 2 3 4 5 6
t[] 0 1 1 1 1 1
</code></pre></div></div>

<p>此时刚刚将3放入数组中。除了1之外，每个数字都出现过了1次。现在求3的答案。目前出现过的数字中，有5,4,6三个数字比3大，则3所贡献的答案为3。观察桶数组，5,4,6这三个数字在3的后面，那么把他们桶数组对应的值相加，就是3所贡献的答案，即t[4] + t[5] + t[6] = 3。这就是在求区间和，可以用上树状数组。</p>

<p>因为将元素从左到右依次读入，所以桶数组所记录的，只是已读入的数组。当前元素右边的数仍未读入，所以不会影响答案（答案求的是，对于一个元素，求左边比它大的元素的个数）。</p>

<p>然而，这里有一个运用桶数组司空见惯的问题。数列中的数字不超过1e9，桶数组装不下，所以要用到离散化。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="n">sort</span><span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> 
                <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 去重</span>
<span class="n">m</span><span class="o">--</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
</code></pre></div></div>

<p>解释:</p>

<ol>
  <li>a数组为原数组，存储了原始值。不能直接在a数组上操作，因为生成索引后，还要根据原始值的大小，来决定分到哪个索引。要保持元素的顺序不变。</li>
  <li>将b数组排序、去重后得到了c数组。排序是为了得到索引。去重可以优化离散化。比如，有1000个相同的数，如果不去重，那么将会生成1000个索引。但是去重后只用生成1个即可。</li>
  <li>对于每个a[i]，在c数组中找到它的位置。lower_bound(f.begin, f.end, value)，就是在数组f的区间[f.begin, f.end]中，找到第一个大于或等于value的元素。</li>
  <li>减去c（数组首地址）得到该元素在c数组中的索引。</li>
</ol>

<p>一个例子：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原数组 60  100 40  30  200
离散化 3   4   2   1   5
</code></pre></div></div>

<p>在离散化后的数组上，再使用上述的思路，就可解决此题。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[树状数组(Binary Indexed Tree) 12 Sep 2025]]></summary></entry><entry><title type="html">单调队列(Monotonic Queue)</title><link href="http://localhost:4000/2025/08/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97Monotonic-Queue.html" rel="alternate" type="text/html" title="单调队列(Monotonic Queue)" /><published>2025-08-17T00:00:00+08:00</published><updated>2025-08-17T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97Monotonic%20Queue</id><content type="html" xml:base="http://localhost:4000/2025/08/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97Monotonic-Queue.html"><![CDATA[<h1 id="单调队列monotonic-queue">单调队列(Monotonic Queue)</h1>
<p class="meta">17 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调队列与单调栈相似。应先学习单调栈，再学习单调队列。</li>
  <li>单调队列保持单调的特性，可以单调递增，也可以单调递减。</li>
  <li>单调队列在动态规划中用于优化状态转移，或处理数据流中的实时最值问题。</li>
</ul>

<p><strong>2.实现</strong></p>

<p>模版：<a href="https://www.luogu.com.cn/problem/P1886">洛谷P1886</a></p>

<p>对于长度为n的序列，有一个长度为k的窗口。窗口从左到右，每次滑动一个单位。求每次滑动后窗口内的最大值和最小值。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input
8  3
1  3  -1  -3  5  3  6  7
</code></pre></div></div>
<p></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output
min -1 -3 -3 -3  3  3
max  3  3  5  5  6  7
</code></pre></div></div>

<p><strong>思路：</strong></p>

<ul>
  <li>
    <p>用一个双端队列deque来模拟窗口。因为窗口在滑动的过程中，一端进，一端出，所以选择队列。另外，队尾既需要push也需要pop，所以使用双端队列。</p>
  </li>
  <li>
    <p>与单调栈相同，单调队列存入的是元素的下标。</p>
  </li>
  <li>
    <p>首先考虑窗口如何滑动。窗口移动之后，在开始求最值前，要先把已经移动到窗口之外的数字从队列中去掉。我们从队尾加入元素，从队头踢出元素。若i表示当前的元素，那么当q.front() &lt; i - k + 1时，说明a.front()已经在窗口之外，应该踢出。</p>
  </li>
  <li>
    <p>窗口滑动完之后，可以开始求最值。求最大值时，若队尾比当前元素小，则踢出。踢出之后，得到新的队尾，继续与当前元素比较，知道队列为空，或队尾大于等于当前元素。求最小值类似。这样是求最值的优化，和单调栈相同，没有必要把整个窗口遍历一遍。</p>
  </li>
  <li>
    <p>比如，在求最大值的时候，我们维护一个从队头到队尾单调递减的队列，那么队头始终是当前元素的答案。</p>

    <p>在样例中，当枚举到元素5时，队列为 [3, -1, -3] (左边为front，右边为back。队列存的是元素而不是下标，方便理解)。</p>

    <p>此时判断3已经在窗口之外，所以踢出。</p>

    <p>对于-1和-3，它们都比当前元素5小。由于5的存在，-1和-3对于后面的元素，不可能成为它们的答案，所以踢出。</p>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 求最大值</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  	<span class="n">maxi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()];</span>
<span class="p">}</span>
</code></pre></div></div>
<p></p>
<p></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 求最小值</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">mini</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()];</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>example 1</strong>: <a href="https://www.luogu.com.cn/problem/P1714">洛谷P1714</a> 求最大字段和 (给定了子段的长度为m)</p>

<p><strong>题意：</strong>
\(在\ p_n中，找出一个子段 [l,r]\ (r−l+1≤m)，最大化 ∑_{i=l}^{r} \  p_i\)
与模版不同之处在于，此题需要求和，而非找到最值。因此需要使用前缀和。</p>

<p>用前缀和将序列处理完成之后，得到一个sum[]的数组，因此求[l,r]区间的和，可以用sum[r]-sum[l-1]来表示。</p>

<p><strong>思路：</strong></p>

<ul>
  <li>对于sum[i]，把它看作区间的右端点。遍历sum数组时，每一轮循环中i的值是确定的，那么右端点也是确定的，所以目标转移到了求左端点。</li>
  <li>区间和表示为sum[r] - sum[l-1]，由于sum[r]是确定的，因此当sum[l-1]最小时，区间和最大。</li>
  <li>所以可以在每一轮循环中，用单调队列找到sum[l-1]的最小值。求sum[l-1]的最小值，已经和单调队列模版没有区别。相当于是一个长度为n的序列 (sum数组)，窗口长度为m，找到每个窗口的最小值。</li>
</ul>

<p><strong>example 2</strong>: <a href="https://www.luogu.com.cn/problem/P2216">洛谷P2216</a> (二维)</p>

<p><strong>题意：</strong></p>

<p>有一个 <em>a</em>×<em>b</em> 的整数组成的矩阵，现请你从中找出一个 <em>n</em>×<em>n</em> 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input
a = 5, b = 4, n = 2
1   2   5   6
0   17  16  0
16  17  2   1
2   10  2   1
1   2   2   2
</code></pre></div></div>
<p></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output
1
</code></pre></div></div>

<p><strong>思路：</strong></p>

<ul>
  <li>这道题也是求区间内的最值，只不过是二维的，那么可以试着将二维转化为一维。</li>
  <li>令 c [i] [j]表示在 (i, j) 所在的竖列中，以 (i, j)为起点，向上的一个长度为n的序列的最大值。如 c[5] [2] = 10，因为它所在的数列为 [2, 10]。</li>
  <li>那么，max(c[i] [j], c[i] [j+1], c[i] [j+2] …….. c[i] [j + n -1]) 就是一个以 (i, j)为左下方顶点的 <em>n</em>×<em>n</em> 矩形中的最大值。求最小值的方法一样，用d[i] [j]表示。</li>
  <li>用单调队列求数组c和数组d，和求滑动窗口中的最值无异。</li>
  <li>处理完数组c和数组d之后，再枚举所有的矩形即可。</li>
</ul>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调队列(Monotonic Queue) 17 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack.html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack.html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">数独优化求解(Solving Sudoku, from Backtracking to CSP Optimizations)</title><link href="http://localhost:4000/2025/08/06/%E6%95%B0%E7%8B%AC%E4%BC%98%E5%8C%96%E6%B1%82%E8%A7%A3Solving-Sudoku-From-Backtracking-to-CSP-Optimizations.html" rel="alternate" type="text/html" title="数独优化求解(Solving Sudoku, from Backtracking to CSP Optimizations)" /><published>2025-08-06T00:00:00+08:00</published><updated>2025-08-06T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/06/%E6%95%B0%E7%8B%AC%E4%BC%98%E5%8C%96%E6%B1%82%E8%A7%A3Solving%20Sudoku%20From%20Backtracking%20to%20CSP%20Optimizations</id><content type="html" xml:base="http://localhost:4000/2025/08/06/%E6%95%B0%E7%8B%AC%E4%BC%98%E5%8C%96%E6%B1%82%E8%A7%A3Solving-Sudoku-From-Backtracking-to-CSP-Optimizations.html"><![CDATA[<h1 id="数独优化求解solving-sudoku-from-backtracking-to-csp-optimizations">数独优化求解(Solving Sudoku, from Backtracking to CSP Optimizations)</h1>
<p class="meta">6 Aug 2025</p>

<h5 id="1introduction"><strong>1.Introduction</strong></h5>

<p>The inspiration for this project arose from a lesson on solving logic puzzles, such as Einstein’s Riddle, using Prolog. The underlying solution approach for Einstein’s Riddle fundamentally relies on search and backtracking algorithms. This experience led to the realization that similar methodologies could be effectively applied to other logic puzzles, including Sudoku. Furthermore, it highlighted the potential for algorithmic improvements, particularly in reducing time complexity. This project explores this potential by implementing and comparing two solution strategies for Sudoku: a basic backtracking algorithm and an optimized approach incorporating CSP (Constraint Satisfaction Problem) techniques.</p>

<h5 id="2background"><strong>2.Background</strong></h5>

<p><strong>Sudoku</strong></p>

<p>As a globally popular logic puzzle, Sudoku is governed by seemingly simple rules: the objective is to fill a 9×9 grid so that each digit from 1 to 9 appears exactly once in every row, column, and 3×3 subgrid. Despite their simplicity, these combinatorial uniqueness constraints define a challenging problem space, classifying Sudoku as a Constraint Satisfaction Problem (CSP), in which valid solutions must simultaneously satisfy all given constraints.</p>

<p><strong>CSP Optimization</strong></p>

<p>CSP optimization refers to a set of techniques designed to enhance the efficiency of solving Constraint Satisfaction Problems. A CSP is defined by three fundamental components: variables, domains, and constraints. By leveraging strategies such as the Minimum Remaining Values (MRV) heuristic and constraint propagation, CSP techniques effectively reduce the search space and eliminate redundant computations, leading to faster and more efficient solutions.</p>

<p>CSP optimization techniques improve solving efficiency by significantly reducing computational complexity. A Constraint Satisfaction Problem (CSP) is defined by three key components: variables (e.g., empty cells in a Sudoku grid), domains (e.g., the set of possible digits {1–9} for each cell), and constraints (e.g., the requirement that each digit appears exactly once in every row, column, and 3×3 subgrid).</p>

<p>A common CSP optimization is achieved through two core strategies. First, the Minimum Remaining Values (MRV) heuristic guides the search by selecting the variable with the fewest valid values remaining, thereby increasing the likelihood of early detection of conflicts and pruning futile branches sooner. Second, constraint propagation dynamically removes inconsistent values from the domains of related variables after each assignment, effectively narrowing the search space and preventing invalid configurations. Together, these techniques greatly enhance the performance of CSP solvers.</p>

<h5 id="3methodology"><strong>3.Methodology</strong></h5>

<p><strong>Backtracking</strong></p>

<p>Backtracking is a fundamental depth-first search (DFS) algorithm widely used in decision-based problem solving. It systematically explores potential solutions by incrementally building candidates and backtracking (reversing previous choices whenever a partial assignment violates the problem’s constraints). The core procedure follows these steps:</p>

<ol>
  <li>Stepwise Assignment: Construct a solution by assigning values to variables one at a time, in a predetermined order.</li>
  <li>Consistency Validation: After each assignment, check whether the current state satisfies all constraints.</li>
  <li>Backtracking Trigger: If no valid value can be assigned to the current variable, undo the most recent assignment and explore alternative values for that variable.</li>
  <li>Termination: Repeat this process until either a complete and valid solution is found or all possible assignments have been exhausted.</li>
</ol>

<p>Due to its systematic exploration and pruning of invalid paths, backtracking is particularly well-suited for problems involving combinations, permutations, and constraint satisfaction, including Sudoku.</p>

<p>In the context of Sudoku, the algorithm begins at the top-left cell of the 9×9 grid and proceeds row by row, from left to right and top to bottom. For each empty cell, it attempts digits from 1 to 9 in sequence, checking whether each candidate value adheres to the Sudoku constraints (i.e., no duplicates in the corresponding row, column, and 3×3 subgrid). If no valid digit can be placed in a cell, the algorithm concludes that an earlier assignment must be incorrect and backtracks to revise previous choices. This iterative process continues until a complete and consistent solution is achieved.</p>

<p><strong>Disadvantages of Backtracking</strong></p>

<p>Although backtracking solves Sudoku puzzles in a straightforward and intuitive manner, it suffers from a critical drawback: an extremely high time complexity of O(9ⁿ), where n is the number of empty cells. This inefficiency arises because the algorithm does not fully leverage the inherent structure of Sudoku’s constraints. Specifically, backtracking only applies the rules—such as the requirement for unique digits in each row, column, and 3×3 subgrid—to validate a guess after it has been made, rather than using them proactively to guide and prune the search space.</p>

<p>For example, if the digit 4 already appears in row 1, it is impossible for 4 to appear again in any other empty cell of that row. However, standard backtracking does not eliminate 4 from the candidate list for those cells in advance, potentially leading to redundant and invalid guesses. By failing to incorporate constraint information earlier in the process, the algorithm wastes time exploring paths that could have been ruled out immediately. This highlights a key opportunity for optimization through more intelligent use of the puzzle’s constraints during the search.</p>

<p><strong>Introducing MRV and Constraints Propagation</strong></p>

<p>To enhance the efficiency of backtracking, we incorporate Constraint Satisfaction Problem (CSP) optimization techniques. First, we apply the Minimum Remaining Values (MRV) heuristic, which selects the next empty cell to assign based on the fewest number of valid candidate values. This strategy helps to quickly expose dead ends and prune unproductive branches of the search tree early. Second, we implement constraint propagation, which actively enforces Sudoku’s core constraints, namely, the requirement that each digit from 1 to 9 must appear exactly once in every row, column, and 3×3 subgrid. As values are assigned, this technique dynamically eliminates invalid candidates from the domains of related unassigned cells, thereby reducing the search space and minimizing the number of futile guesses. Together, these optimizations significantly improve the solver’s performance by making the search process more informed and efficient.</p>

<h5 id="4implementation"><strong>4.Implementation</strong></h5>

<p><strong>Backtracking Algorithm Implementation</strong></p>

<div style="text-align: center;">
  <img src="/images/monoqueue/flow.png" alt="图片1" style="display: block; margin: 0 auto;zoom:110%;" />
</div>

<p>The backtracking implementation consists of a main for loop that systematically fills empty cells while maintaining Sudoku constraints. When a cell cannot be filled with any valid number, the algorithm backtracks to the previous modifiable cell and tries the next available number.</p>

<p>The following code shows how the backtracking algorithm is implemented.</p>

<div style="text-align: center;">
  <img src="/images/monoqueue/algo1.png" alt="图片2" style="display: block; margin: 0 auto; zoom:110%;" />
</div>

<p>The following code shows how the function, solve(), is called in the main function.</p>

<div style="text-align: center;">
  <img src="/images/monoqueue/main.png" alt="图片3" style="display: block; margin: 0 auto; zoom:60%;" />
</div>

<p><strong>MRV and Constraint Propagation Implementation</strong></p>

<div style="text-align: center;">
  <img src="/images/monoqueue/flow2.png" alt="图片4" style="display: block; margin: 0 auto; zoom:100%;" />
</div>

<p>Building upon the backtracking logic and code, the version incorporating Constraint Propagation and MRV has added two functions to optimize the algorithm. It first calls the propagate_constraints () function to eliminate scenarios with obvious contradictions. Then, it invokes the find_mrv_cell () function to ensure the next step is the one most likely to either advance the solution or detect conflicts. When searching for values for an empty cell, only numbers recorded in the candidate array (i.e., valid possibilities) are tried, rather than sequentially testing numbers from 1 to 9. If a cell cannot be filled with any valid number, the algorithm backtracks to the previous modifiable cell and attempts the next available number.</p>

<p>The following code shows how the Propagate Constraints and MRV Version is implemented.</p>

<div style="text-align: center;">
  <img src="/images/monoqueue/algo2.png" alt="图片5" style="display: block; margin: 0 auto; max-width: 550px; max-height: 350px;" />
</div>
<h5 id="5experimental-evaluation"><strong>5.Experimental evaluation</strong></h5>

<div class="three-line-table">
  <table>
    <thead>
      <tr>
        <th>Category</th>
        <th>Easy</th>
        <th>Medium</th>
        <th>Hard</th>
        <th>Harder</th>
        <th>Very hard</th>
        <th>Super hard</th>
        <th>Impossible</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Backtracking</td>
        <td>268.00</td>
        <td>399.57</td>
        <td>10901.7</td>
        <td>935.86</td>
        <td>1067.29</td>
        <td>1681.29</td>
        <td>7703.14</td>
      </tr>
      <tr>
        <td>MRV &amp; Propagate Constraints</td>
        <td>171.50</td>
        <td>206.43</td>
        <td>731.43</td>
        <td>163.71</td>
        <td>287.14</td>
        <td>123.57</td>
        <td>5153.14</td>
      </tr>
      <tr>
        <td>Speed up</td>
        <td>1.56</td>
        <td>1.94</td>
        <td>14.90</td>
        <td>5.72</td>
        <td>3.72</td>
        <td>13.61</td>
        <td>1.49</td>
      </tr>
    </tbody>
  </table>
</div>

<div style="text-align: center;">
  <img src="/images/monoqueue/zhu.png" alt="图片5" style="display: block; margin: 0 auto; max-width: 500px; max-height: 300px;" />
</div>

<p>As shown in Figure 1, the new version has improved the algorithm’s performance by approximately 1.5 to 15 times through optimizations based on the Minimum Remaining Value (MRV) and constraint propagation.</p>

<p>As shown in Figure 2, regarding backtracking, except for the “Hard” difficulty level, its processing time for Sudoku puzzles shows an upward trend with the increase in difficulty. As for the optimized version, except for the “Impossible” difficulty level, its processing time tends to be stable.</p>

<p>However, as shown in Figure 2, the data of the “Hard” difficulty level does not conform to the pattern in the graph. Initially, I controlled the difficulty of Sudoku by limiting the number of known numbers. But in subsequent experiments, the obtained experimental data did not conform to basic logic, and it was then discovered that the number of known numbers cannot accurately represent the difficulty of Sudoku. Therefore, I speculate that the difficulty of Sudoku may also be determined by factors such as the arrangement of numbers. In addition, a specific algorithm may be good at or not good at handling a certain type of number arrangement. Thus, the abnormal data in the “Hard” difficulty level may be caused by the above-mentioned reasons.</p>

<h5 id="6conclusion"><strong>6.Conclusion</strong></h5>

<p>This study demonstrates that integrating CSP optimization techniques (MRV and constraint propagation) can significantly enhance the efficiency of Sudoku-solving algorithms, achieving a speedup of 1.5 to 15 times. The backtracking algorithm exhibits inconsistent performance across different difficulty levels, whereas the optimized version maintains relatively stable processing efficiency. It is also confirmed that Sudoku difficulty is not solely determined by the number of known digits but is also affected by factors such as number arrangement, which warrants further exploration.</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[数独优化求解(Solving Sudoku, from Backtracking to CSP Optimizations) 6 Aug 2025]]></summary></entry></feed>