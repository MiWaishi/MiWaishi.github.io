<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-08-18T19:34:32+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">sun Blog Title</title><subtitle>A brief description of your blog.</subtitle><author><name>Your Name</name><email>your-email@example.com</email></author><entry><title type="html">单调队列(Monotonic Queue)</title><link href="http://localhost:4000/2025/08/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97Monotonic-Queue.html" rel="alternate" type="text/html" title="单调队列(Monotonic Queue)" /><published>2025-08-17T00:00:00+08:00</published><updated>2025-08-17T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97Monotonic%20Queue</id><content type="html" xml:base="http://localhost:4000/2025/08/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97Monotonic-Queue.html"><![CDATA[<h1 id="单调队列monotonic-queue">单调队列(Monotonic Queue)</h1>
<p class="meta">17 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调队列与单调栈相似。应先学习单调栈，再学习单调队列。</li>
  <li>单调队列保持单调的特性，可以单调递增，也可以单调递减。</li>
  <li>单调队列在动态规划中用于优化状态转移，或处理数据流中的实时最值问题。</li>
</ul>

<p><strong>2.实现</strong></p>

<p>模版：<a href="https://www.luogu.com.cn/problem/P1886">洛谷P1886</a></p>

<p>对于长度为n的序列，有一个长度为k的窗口。窗口从左到右，每次滑动一个单位。求每次滑动后窗口内的最大值和最小值。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input
8  3
1  3  -1  -3  5  3  6  7
</code></pre></div></div>
<p></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output
min -1 -3 -3 -3  3  3
max  3  3  5  5  6  7
</code></pre></div></div>

<p><strong>思路：</strong></p>

<ul>
  <li>
    <p>用一个双端队列deque来模拟窗口。因为窗口在滑动的过程中，一端进，一端出，所以选择队列。另外，队尾既需要push也需要pop，所以使用双端队列。</p>
  </li>
  <li>
    <p>与单调栈相同，单调队列存入的是元素的下标。</p>
  </li>
  <li>
    <p>首先考虑窗口如何滑动。窗口移动之后，在开始求最值前，要先把已经移动到窗口之外的数字从队列中去掉。我们从队尾加入元素，从队头踢出元素。若i表示当前的元素，那么当q.front() &lt; i - k + 1时，说明a.front()已经在窗口之外，应该踢出。</p>
  </li>
  <li>
    <p>窗口滑动完之后，可以开始求最值。求最大值时，若队尾比当前元素小，则踢出。踢出之后，得到新的队尾，继续与当前元素比较，知道队列为空，或队尾大于等于当前元素。求最小值类似。这样是求最值的优化，和单调栈相同，没有必要把整个窗口遍历一遍。</p>
  </li>
  <li>
    <p>比如，在求最大值的时候，我们维护一个从队头到队尾单调递减的队列，那么队头始终是当前元素的答案。</p>

    <p>在样例中，当枚举到元素5时，队列为 [3, -1, -3] (左边为front，右边为back。队列存的是元素而不是下标，方便理解)。</p>

    <p>此时判断3已经在窗口之外，所以踢出。</p>

    <p>对于-1和-3，它们都比当前元素5小。由于5的存在，-1和-3对于后面的元素，不可能成为它们的答案，所以踢出。</p>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 求最大值</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  	<span class="n">maxi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()];</span>
<span class="p">}</span>
</code></pre></div></div>
<p></p>
<p></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 求最小值</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">mini</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()];</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>example 1</strong>: <a href="https://www.luogu.com.cn/problem/P1714">洛谷P1714</a> 求最大字段和 (给定了子段的长度为m)</p>

<p><strong>题意：</strong>
\(在\ p_n中，找出一个子段 [l,r]\ (r−l+1≤m)，最大化 ∑_{i=l}^{r} \  p_i\)
与模版不同之处在于，此题需要求和，而非找到最值。因此需要使用前缀和。</p>

<p>用前缀和将序列处理完成之后，得到一个sum[]的数组，因此求[l,r]区间的和，可以用sum[r]-sum[l-1]来表示。</p>

<p><strong>思路：</strong></p>

<ul>
  <li>对于sum[i]，把它看作区间的右端点。遍历sum数组时，每一轮循环中i的值是确定的，那么右端点也是确定的，所以目标转移到了求左端点。</li>
  <li>区间和表示为sum[r] - sum[l-1]，由于sum[r]是确定的，因此当sum[l-1]最小时，区间和最大。</li>
  <li>所以可以在每一轮循环中，用单调队列找到sum[l-1]的最小值。求sum[l-1]的最小值，已经和单调队列模版没有区别。相当于是一个长度为n的序列 (sum数组)，窗口长度为m，找到每个窗口的最小值。</li>
</ul>

<p><strong>example 2</strong>: <a href="https://www.luogu.com.cn/problem/P2216">洛谷P2216</a> (二维)</p>

<p><strong>题意：</strong></p>

<p>有一个 <em>a</em>×<em>b</em> 的整数组成的矩阵，现请你从中找出一个 <em>n</em>×<em>n</em> 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input
a = 5, b = 4, n = 2
1   2   5   6
0   17  16  0
16  17  2   1
2   10  2   1
1   2   2   2
</code></pre></div></div>
<p></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output
1
</code></pre></div></div>

<p><strong>思路：</strong></p>

<ul>
  <li>这道题也是求区间内的最值，只不过是二维的，那么可以试着将二维转化为一维。</li>
  <li>令 c [i] [j]表示在 (i, j) 所在的竖列中，以 (i, j)为起点，向上的一个长度为n的序列的最大值。如 c[5] [2] = 10，因为它所在的数列为 [2, 10]。</li>
  <li>那么，max(c[i] [j], c[i] [j+1], c[i] [j+2] …….. c[i] [j + n -1]) 就是一个以 (i, j)为左下方顶点的 <em>n</em>×<em>n</em> 矩形中的最大值。求最小值的方法一样，用d[i] [j]表示。</li>
  <li>用单调队列求数组c和数组d，和求滑动窗口中的最值无异。</li>
  <li>处理完数组c和数组d之后，再枚举所有的矩形即可。</li>
</ul>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调队列(Monotonic Queue) 17 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-10).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2010)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-10).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-11).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2011)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-11).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-12).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2012)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-12).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-13).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2013)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-13).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-14).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2014)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-14).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-15).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2015)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-15).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-16).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%2016)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-16).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-2).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%202)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-2).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry><entry><title type="html">单调栈 (Monotonic Stack)</title><link href="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-3).html" rel="alternate" type="text/html" title="单调栈 (Monotonic Stack)" /><published>2025-08-10T00:00:00+08:00</published><updated>2025-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic%20Stack%20(Copy%203)</id><content type="html" xml:base="http://localhost:4000/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack-(Copy-3).html"><![CDATA[<h1 id="单调栈-monotonic-stack">单调栈 (Monotonic Stack)</h1>
<p class="meta">10 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调栈 (Monotonic Stack) 是一种解题工具，而非算法。</li>
  <li>单调栈在复杂题目中，不会单独出现，一般用于完成部分功能，如处理数据。</li>
  <li>其模版问题是：对于数列中某元素，找出其左边/右边<strong>第一个</strong>比它大/小的元素的<strong>下标</strong>。</li>
</ul>

<p><strong>2.实现</strong></p>

<p><strong>模版：</strong><a href="https://www.luogu.com.cn/problem/P5788">洛谷P5788</a></p>

<p>对于长度为n的序列a，定义f(i)为第i个元素后第一个大于a[i]的元素的下标。若不存在，则f(i)为0。求f(1~n),
\(数据范围:n \leq 3 \times 10^6\)
。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]: 1 4 2 3 5
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(): 2 5 4 5 0
</code></pre></div></div>

<p>样例解释：</p>

<ul>
  <li>i = 1时，a[i] = 1. 其右边第一个比a[1]大的元素为4, 其下标为2. 故f(1) = 2。</li>
  <li>i = 2时，a[i] = 4. 其右边第一个比a[2]大的元素为5, 其下标为5. 故f(2) = 5。</li>
</ul>

<p><strong>思路：</strong></p>

<ul>
  <li>维护一个vector模拟单调栈，f[ ]数组记录答案。</li>
  <li>从数列的右边向左边处理。</li>
  <li>对于每一个a[i]，将其和栈顶元素比较。如a[i]更大，则将栈顶元素pop. pop之后的新栈顶继续和a[i]比较，直到栈顶元素比a[i]更大，或者栈的所有元素都被踢出。</li>
  <li>若栈中仍剩有元素，则栈顶元素为a[i]的答案，即f(i)。</li>
  <li>再将当前元素 (的下标) 加入栈中。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">3000010</span><span class="p">];</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stk</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">stk</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">stk</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
		<span class="n">stk</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>程序运行过程：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a[]:   1 4 2 3 5
index: 1 2 3 4 5
</code></pre></div></div>

<ul>
  <li>处理5。此时栈为空，所以while和if都不会执行，直接将5加入栈中。由于5的右边没有数字，所以f(5)为0。</li>
  <li>处理3。此时栈中含有5。5比3大，即栈顶比a[i]大，所以while不会执行。f(4)通过if语句赋值为5。 将3加入栈中。</li>
  <li>处理2。此时栈中含有3和5(栈顶为3)。3比2大，即栈顶比a[i]大，所以while不会执行。f(3)通过if语句赋值为3。将2加入栈中。</li>
  <li>处理4。此时栈中含有2,3,5(栈顶为2)。4比2大，即a[i]比栈顶大，且栈不为空，所以执行while。while中，将2和3踢出栈。f(2)通过if语句赋值为5。将4加入栈中。</li>
  <li>处理1。此时栈中还有4,5(栈顶为4)。4比1大，即栈顶比a[i]大，所以while不会执行。f(1)通过if语句赋值为4。</li>
</ul>

<p><strong>解析</strong>：</p>

<p>在从右向左的处理过程中，不断从栈中删去元素起到了优化的作用：当前元素若比栈顶元素大，则将栈顶元素删去。为什么可以把栈顶元素删去？在if语句中可知，我们始终把栈顶作为当前的答案，赋值给f[i]，并且不断更新栈顶。其逻辑是这样的：对于左边还未处理的元素，删去栈顶元素意味着这个栈顶元素不可能成为后面元素的答案。为什么呢？因为对于左边未处理的元素，我们已经找到了更加靠近的，且数字更大的元素，就是正在处理的元素。结合题目的要求，即找到所有元素右边第一个比它大的元素的下标，就很好理解了。</p>

<p>举个例子，入本题的样例。在处理元素4的时候，将2和3从栈中删除了。这样做是为了减少在求解后面元素的答案时所需要的时间。因为对于1而言，4要比2和3更加靠近1，并且数值更大，所以2和3肯定不可能是1的答案，所以将2和3删去。</p>

<p>另外，使用vector模拟单调栈，编码时更加方便，具体有以下优势：</p>

<ul>
  <li>可通过索引直接访问元素，如vector[i]。而stack只能访问栈顶元素。</li>
  <li>可以使用STL中的函数，如sort, find。</li>
</ul>

<p>最后，上文在解释时为了方便，都把入栈的操作说成是“一个元素入栈”。实际上是“元素的下标”入栈，因为题目求的是下标。而且在调用栈顶元素时，要记得要当做下标来用。如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">[</span><span class="n">stk</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span>
</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>Example 1</strong>: <a href="https://www.luogu.com.cn/problem/P2866">洛谷P2866</a></p>

<p>这题是一个简单的变形。所求的问题可简化为：找出每个元素左边第一个比它大的元素。对于所有的元素，以目标元素为左端点，当前元素为右端点，求区间长度之和。</p>

<p><strong>Example 2</strong>: <a href="https://www.luogu.com.cn/problem/U478856">洛谷U478856</a></p>

<p>题意：对于一个长度为n的序列，求出所有区间的最大值的和。</p>

<p>此题难度比上题略高，不能简单的套用单调栈模版了。其核心思路是：<strong>对于每一个元素，找出以此元素为最大值的区间的数量。</strong>用c[i]表示以a[i]为最大值的区间数，那么答案则是：
\(\sum_{i=1}^{n} c_i \times a_i\)
另外，求具体如何求区间数呢？需要从左到右，从右到左跑两遍单调栈，对于每一个元素，分别求左边第一个更大的元素，和右边第一个更大的元素。这样确定了最大的区间，但不是我们想要的。我们想要的是所有的区间数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        4   8   3   5   7   1   9   6
            l           i       r
index   1   2   3   4   5   6   7   8
</code></pre></div></div>
<p>比如，在此数列中，对于元素7，在跑两遍单调栈后，我们得到对于7的最大区间，左端点为8，右端点为9 (不包括端点)。    那么c[i] = (i - l) * (r - i)。其中，对于所有可能区间，i - l 表示了左端点的所有可能，r - i表示了右端点的算有可能。此公式可理解为一个排列问题。具体来看，对于7，c[7] = (5 - 2) * (7 - 5)  = 6。</p>

<p><strong>Example 3</strong> <a href="https://www.luogu.com.cn/problem/B4273">洛谷B4273</a></p>

<p>此为一道单调栈的二维变形。如下图，每个长方形的底一样长，高不同，要找出一个面积最大的矩形，输入每个矩形的高。</p>

<!--![tu1](images/monostack.jpg "tu1")-->

<div style="text-align: center;">
  <img src="/images/monostack/monostack.jpg" alt="示例图片" style="display: block; margin: 0 auto;zoom:20%;" />
</div>

<p>此题和上题有异曲同工之妙。对于当前标红的纸条，向左右延伸，直到不能再延伸，以这种方式找到一个矩形，如图中用蓝框圈起的矩形。令此纸条高度为h，那么就找到了高度为h的矩形的面积的最大值。尝试所有的每个纸条的高度，求max，则能找到答案。</p>

<p>如何实现呢？已知输入代表了每个纸条的高度。对于每个数字，用单调栈，找到它左右第一个比它小的元素，求区间长度。用区间长度乘以纸条高度，就得到了当前高度的最大面积。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3 2 1 4 5 2
</code></pre></div></div>

<p>对于其他二维变形，可以把此题作为基础，将其他二维变形往这道题上去套，可能可以找到思路。</p>]]></content><author><name>Your Name</name><email>your-email@example.com</email></author><summary type="html"><![CDATA[单调栈 (Monotonic Stack) 10 Aug 2025]]></summary></entry></feed>