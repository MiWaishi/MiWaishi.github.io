<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>单调队列(Monotonic Queue)</title>
   <meta name="author" content="Sitan Chen />
   <link href="http://feeds.feedburner.com/tom-preston-werner" rel="alternate" title="Sitan Chen" type="application/atom+xml" />
   <meta name="readability-verification" content="QCzSs992GxmRYRKVpPeZ6LE2tS8aYKxsSSQKV8YM"/>

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- Typekit -->
   <script type="text/javascript" src="http://use.typekit.com/jpd0pfm.js"></script>
   <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
  
   <!-- Mathjax -->
   <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
   <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
   
</head>
<body>

<!-- ClickTale Top part -->
<script type="text/javascript">
var WRInitTime=(new Date()).getTime();
</script>
<!-- ClickTale end of Top part -->

<div class="site">
  <div class="title">
    <a href="/">Sitan Chen</a>
    <a class="extra" href="/">home</a>
  </div>

  <div id="post">
<h1 id="单调队列monotonic-queue">单调队列(Monotonic Queue)</h1>
<p class="meta">17 Aug 2025</p>

<p><strong>1.简介</strong></p>

<ul>
  <li>单调队列与单调栈相似。应先学习单调栈，再学习单调队列。</li>
  <li>单调队列保持单调的特性，可以单调递增，也可以单调递减。</li>
  <li>单调队列在动态规划中用于优化状态转移，或处理数据流中的实时最值问题。</li>
</ul>

<p><strong>2.实现</strong></p>

<p>模版：<a href="https://www.luogu.com.cn/problem/P1886">洛谷P1886</a></p>

<p>对于长度为n的序列，有一个长度为k的窗口。窗口从左到右，每次滑动一个单位。求每次滑动后窗口内的最大值和最小值。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
input
8  3
1  3  -1  -3  5  3  6  7

</code></pre></div></div>
<p></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
output
min -1 -3 -3 -3  3  3
max  3  3  5  5  6  7

</code></pre></div></div>

<p><strong>思路：</strong></p>

<ul>
  <li>
    <p>用一个双端队列deque来模拟窗口。因为窗口在滑动的过程中，一端进，一端出，所以选择队列。另外，队尾既需要push也需要pop，所以使用双端队列。</p>
  </li>
  <li>
    <p>与单调栈相同，单调队列存入的是元素的下标。</p>
  </li>
  <li>
    <p>首先考虑窗口如何滑动。窗口移动之后，在开始求最值前，要先把已经移动到窗口之外的数字从队列中去掉。我们从队尾加入元素，从队头踢出元素。若i表示当前的元素，那么当q.front() &lt; i - k + 1时，说明a.front()已经在窗口之外，应该踢出。</p>
  </li>
  <li>
    <p>窗口滑动完之后，可以开始求最值。求最大值时，若队尾比当前元素小，则踢出。踢出之后，得到新的队尾，继续与当前元素比较，知道队列为空，或队尾大于等于当前元素。求最小值类似。这样是求最值的优化，和单调栈相同，没有必要把整个窗口遍历一遍。</p>
  </li>
  <li>
    <p>比如，在求最大值的时候，我们维护一个从队头到队尾单调递减的队列，那么队头始终是当前元素的答案。</p>

    <p>在样例中，当枚举到元素5时，队列为 [3, -1, -3] (左边为front，右边为back。队列存的是元素而不是下标，方便理解)。</p>

    <p>此时判断3已经在窗口之外，所以踢出。</p>

    <p>对于-1和-3，它们都比当前元素5小。由于5的存在，-1和-3对于后面的元素，不可能成为它们的答案，所以踢出。</p>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 求最大值</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  	<span class="n">maxi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()];</span>
<span class="p">}</span>

</code></pre></div></div>
<p></p>
<p></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 求最小值</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">back</span><span class="p">()]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">mini</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">()];</span>
<span class="p">}</span>

</code></pre></div></div>

<p><strong>3.变形</strong></p>

<p><strong>example 1</strong>: <a href="https://www.luogu.com.cn/problem/P1714">洛谷P1714</a> 求最大字段和 (给定了子段的长度为m)</p>

<p><strong>题意：</strong>
\(在\ p_n中，找出一个子段 [l,r]\ (r−l+1≤m)，最大化 ∑_{i=l}^{r} \  p_i\)
与模版不同之处在于，此题需要求和，而非找到最值。因此需要使用前缀和。</p>

<p>用前缀和将序列处理完成之后，得到一个sum[]的数组，因此求[l,r]区间的和，可以用sum[r]-sum[l-1]来表示。</p>

<p><strong>思路：</strong></p>

<ul>
  <li>对于sum[i]，把它看作区间的右端点。遍历sum数组时，每一轮循环中i的值是确定的，那么右端点也是确定的，所以目标转移到了求左端点。</li>
  <li>区间和表示为sum[r] - sum[l-1]，由于sum[r]是确定的，因此当sum[l-1]最小时，区间和最大。</li>
  <li>所以可以在每一轮循环中，用单调队列找到sum[l-1]的最小值。求sum[l-1]的最小值，已经和单调队列模版没有区别。相当于是一个长度为n的序列 (sum数组)，窗口长度为m，找到每个窗口的最小值。</li>
</ul>

<p><strong>example 2</strong>: <a href="https://www.luogu.com.cn/problem/P2216">洛谷P2216</a> (二维)</p>

<p><strong>题意：</strong></p>

<p>有一个 <em>a</em>×<em>b</em> 的整数组成的矩阵，现请你从中找出一个 <em>n</em>×<em>n</em> 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
input
a = 5, b = 4, n = 2
1   2   5   6
0   17  16  0
16  17  2   1
2   10  2   1
1   2   2   2

</code></pre></div></div>
<p></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
output
1

</code></pre></div></div>

<p><strong>思路：</strong></p>

<ul>
  <li>这道题也是求区间内的最值，只不过是二维的，那么可以试着将二维转化为一维。</li>
  <li>令 c [i] [j]表示在 (i, j) 所在的竖列中，以 (i, j)为起点，向上的一个长度为n的序列的最大值。如 c[5] [2] = 10，因为它所在的数列为 [2, 10]。</li>
  <li>那么，max(c[i] [j], c[i] [j+1], c[i] [j+2] …….. c[i] [j + n -1]) 就是一个以 (i, j)为左下方顶点的 <em>n</em>×<em>n</em> 矩形中的最大值。求最小值的方法一样，用d[i] [j]表示。</li>
  <li>用单调队列求数组c和数组d，和求滑动窗口中的最值无异。</li>
  <li>处理完数组c和数组d之后，再枚举所有的矩形即可。</li>
</ul>


</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>12 Sep 2025</span> &raquo; <a href="/2025/09/12/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84Binary-Indexed-Tree.html">树状数组(Binary Indexed Tree)</a></li>
    
      <li><span>10 Aug 2025</span> &raquo; <a href="/2025/08/10/%E5%8D%95%E8%B0%83%E6%A0%88-Monotonic-Stack.html">单调栈 (Monotonic Stack)</a></li>
    
      <li><span>06 Aug 2025</span> &raquo; <a href="/2025/08/06/%E6%95%B0%E7%8B%AC%E4%BC%98%E5%8C%96%E6%B1%82%E8%A7%A3Solving-Sudoku-From-Backtracking-to-CSP-Optimizations.html">数独优化求解(Solving Sudoku, from Backtracking to CSP Optimizations)</a></li>
    
  </ul>
</div>

  <div class="footer">
    <div class="contact">
      <p>
        Sitan Chen
        <br />
        If you have the same hobbies, you can contact me. 
        <br />
        stanchenx@outlook.com
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="http://github.com/miwaishi/">github.com/miwaishi</a><br />
        
      </p>
    </div>
    <div class="rss">
      
        <img src="/images/rss.png" alt="Subscribe to RSS Feed" />
      </a>
    </div>
  </div>
</div>



<!-- ClickTale Bottom part -->
<div id="ClickTaleDiv" style="display: none;"></div>
<script type="text/javascript">
if(document.location.protocol!='https:')
  document.write(unescape("%3Cscript%20src='http://s.clicktale.net/WRb.js'%20type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
if(typeof ClickTale=='function') ClickTale(206,0.3,"www03");
</script>
<!-- ClickTale end of Bottom part -->

<!-- Google Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-6016902-1");
pageTracker._trackPageview();
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">Total visits to this site: <span id="busuanzi_value_site_pv"></span> times</span>
<!-- Google Analytics end -->

<div>
   <br><br><br><br> <!-- 添加空行 -->
</div>
</body>

</html>
